/**
 *	Mode Lighting
 *
 *	Author: SmartThings, modified by Bruce Ravenel
 *	Date: 2015-04-19
 */
definition(
    name: "Mode Lighting",
    namespace: "bravenel",
    author: "SmartThings, Bruce Ravenel",
    description: "Set Dimmer Levels Based on Mode",
    category: "Convenience",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/MyApps/Cat-MyApps.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/MyApps/Cat-MyApps@2x.png"
)

/**
    This app is hardwired for 3 modes named Day, Evening, and Night (easily changed).
    Edit lines 160, 161 and 162 to change the modes used in the app.
    The dim levels for the 3 modes are entered as a single 6 digit number, e.g. 903510,
    which would give 90 for Day, 35 for Evening, and 10 for Night (or corresponding modes).
    The app also allows you to specify additional dimmers that are turned off
    when the master dimmer is turned off.  The app has similar functionality to 
    Dim With Me, in that there is a master dimmer and some slave dimmers. The
    idea for that is that sometimes the master dimmer physical switch is used to
    turn on the lights -- the slaves follow, or likewise to turn off some lights.  That's
    how I use it, for a master off for an entire area, encompassing more than would be turned on.
    
    It should be noted that for this to work, one must use an instant reporting z-wave dimmer.
    One such dimmer is the Leviton VRMX1 (which must be included directly to the hub to have instant).
    
    If motion sensors(s) are specified they turn on the master and all slaves to the 
    current mode's dimmer level.  The motion activation can be conditioned on times of day,
    days of week, or modes.  Other sensors can be used for turning off after x minutes.
    
    The app adjusts dimmer levels on each mode change to one of the three hardwired modes.
    A mode change to some other mode has no effect on the dimmer levels, which allows for
    extra modes that can be used to disable motion entirely at times. For an instance of the
    app without motion, if the lights are off at mode change, the app will adjust their
    dimmer levels using a modified device type.  This is so that the next time
    the lights are turned on using the physical switch, they come on to the right level.  
    Without this feature, the light would come on to its previous dimmer level, and then
    adjust the level once ST sees the lights-on event.  This can be a number of seconds 
    after the physical switch is pressed.  What you don't want is for someone to go into
    the bathroom in the middle of the night, turn on a switch, and have the light come on
    bright for a few seconds before it dims to the correct level.
    
    There is one more feature of this app that has to do with someone manually changing the
    dimmer level.  For example, in the evening, a woman wants to put on makeup and the light
    isn't bright enough.  She turns up the dimmer.  That event is responded to by temporarily
    adjusting the dimmer level for both master and slaves to that new level.  Once the light is turned off, 
    the dimmer levels will be restored to their mode-specific settings.  Without this feature, she could 
    brighten the lights only to have the app put them right back where they were before.
 */

preferences {
    page(name: "selectDimmers")
    page(name: "otherSettings")
	
	page(name: "timeIntervalInput", title: "Only during a certain time") {
		section {
			input "starting", "time", title: "Starting", required: false
			input "ending", "time", title: "Ending", required: false
		}
	}
}

def selectDimmers() {
	dynamicPage(name: "selectDimmers", title: "First, select your dimmers", nextPage: "otherSettings", uninstall: true) {

		section("When This...") { 
			input "master", "capability.switchLevel", multiple: false, title: "Master Dimmer Is Turned On...", required: true
		}

		section("Then the Master and these Dimmers...") {
			input "dimmers", "capability.switchLevel", multiple: true, title: "Dimmer(s) will be set...", required: false
		}
        
		section("Use these dim levels") {
			input "digits6", "number", title: "Use form DDEENN: ", required: true, description: "DDEENN"
		}
		
		section {
			label title: "Assign a name:", required: false
		}	
	}
}

def otherSettings() {
	dynamicPage(name:"otherSettings", uninstall: false, install: true) {

		section("These switches will be turned off...") {
			input "offSwitches", "capability.switch", title: "These switches off when master off...", multiple: true, required: false
		}
        
		section("Turn on with this button...") {
			input "trigger", "capability.momentary", title: "Button to turn on", multiple: false, required: false
		}
    
		section("Turn them On when there is...") {
			input "motions", "capability.motionSensor", title: "Motion Here", required: false, multiple: true
		}
        
		section("Turn them Off when there is no motion...") {
			input "offMotions", "capability.motionSensor", title: "on these sensors:", required: false, multiple: true
			input "minutes", "number", title: "For this many minutes", required: false, multiple: false
		}
	
		section(title: "Motion options", hidden: hideOptionsSection(), hideable: true) {

			def timeLabel = timeIntervalLabel()

			href "timeIntervalInput", title: "Only during a certain time", description: timeLabel ?: "Tap to set", state: timeLabel ? "complete" : null

			input "days", "enum", title: "Only on certain days of the week", multiple: true, required: false,
				options: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

			input "modes", "mode", title: "Only when mode is", multiple: true, required: false
   		}    
	}
}


def installed() {
	initialize()
}

def updated() {
	unsubscribe()
	initialize()
}


def initialize() {
	subscribe(master, "switch.on", switchOnHandler)
	subscribe(master, "switch.off", switchOffHandler)
	subscribe(master, "level", levelHandler)
	dimmers.each {subscribe(it, "level", levelHandler)}
	subscribe(location, modeChangeHandler)
	subscribe(motions, "motion.active", motionOnHandler)
	subscribe(offMotions, "motion.inactive", motionOffHandler)
	subscribe(trigger, "switch.on", buttonOnHandler)
//	
//	this part converts the 6 digit number into the three dimLevels
//
	def digits4 = digits6 % 10000
	def right2 = digits4 % 100
	def mid2 = digits4 / 100
	def left2 = digits6 / 10000
	state.DayLevel = left2.toInteger()
	state.EveningLevel = mid2.toInteger()
	state.NightLevel = right2
//
	state.currentMode = location.mode
	state.motionOffDismissed = true
	state.masterOff = true
    if(setdimLevel()) if(!state.dimLevel) state.dimLevel = state.DayLevel
}

// change the hardwired modes just below, edit as you need the modes in quotes
boolean setdimLevel(dimLevel) {
	def result = false
	if(dimLevel) state.dimLevel = dimLevel
	else if(location.mode == "Day")     state.dimLevel = state.DayLevel  
	else if(location.mode == "Evening") state.dimLevel = state.EveningLevel
	else if(location.mode == "Night")   state.dimLevel = state.NightLevel
    else result = true
    result
}

def switchesOn(dimLevel) {
	state.motionOffDismissed = true    //we use this variable instead of unschedule() to kill pending off()
	state.masterOff = false            //we track the on/off state of the master dimmer for efficiency
    setdimLevel(dimLevel)
	master.setLevel(state.dimLevel)
	dimmers?.setLevel(state.dimLevel)
}

def switchOnHandler(evt) {
	if(evt.isPhysical()) switchesOn() else state.motionOffDismissed = true
}

def buttonOnHandler(evt) {
	switchesOn()
}

def motionOnHandler(evt) {
	if(state.masterOff && allOk) switchesOn() else state.motionOffDismissed = true
}

def levelHandler(evt) {      // allows a physical dimmer to change the current dimLevel
	if (evt.isDigital() || evt.value == "on" || evt.value == "off") return
	def dimLevel = evt.value.toFloat()
	dimLevel = dimLevel.toInteger()
	switchesOn(dimLevel)
}

def switchesOff() {                    //this is only used by motionOffHandler
	if(state.motionOffDismissed || !allOk) return     //intervening On, kill this Off. Replaces use of unschedule()
	state.masterOff = true
	master.off()
	dimmers?.off()
	offSwitches?.off()
}

def switchOffHandler(evt) {
	state.masterOff = true
	if(evt.isDigital()) return
	if(motions) dimmers?.off() 
	else {    //WARNING: This will fail unless you have custom device type "Dimmer Switch with Off"
		if(master.currentLevel != state.dimLevel) master.resetLevel(state.dimLevel) 
		dimmers.each {if(it.currentLevel != state.dimLevel) it.resetLevel(state.dimLevel) else it.off()}
	}
	offSwitches?.off()
}

def motionOffHandler(evt) {  // called when motion goes inactive, check all sensors
	if(allOk) {
		def noMotion = true
		offMotions.each {noMotion = noMotion && it.currentValue("motion")=="inactive"}
		if(noMotion) {
			state.motionOffDismissed = false
			if(minutes > 0) runIn(minutes*60,switchesOff)
			else switchesOff()
		}
	}
}

// Must use a custom version of Dimmer Switch device type: "Dimmer Switch with Off"
// resetLevel() is used to set the level and then immediately turn off the dimmer.
// This device type is REQUIRED for instances of the app with no motion sensors!

def modeChangeHandler(evt) {
	if(state.currentMode == location.mode) return  // if our mode didn't actually change
	if(setdimLevel()) return                       // if not one of our 3 modes
    state.currentMode = location.mode			   // ok, new mode
    
    // the next two lines brighten any lights on when new mode is brighter than previous
    
	if(master.currentSwitch == "on" && master.currentLevel < state.dimLevel) master.setLevel(state.dimLevel)
	dimmers.each {if(it.currentSwitch == "on" && it.currentLevel < state.dimLevel) it.setLevel(state.dimLevel)}

	if(motions) return
    
    // for rooms with no motion, reset the dimLevel IF off
    
	if(master.currentSwitch == "off") master.resetLevel(state.dimLevel)
	dimmers.each {if(it.currentSwitch == "off") it.resetLevel(state.dimLevel)}
}

// execution filter methods
private getAllOk() {
	modeOk && daysOk && timeOk
}

private getModeOk() {
	def result = !modes || modes.contains(location.mode)
//	log.trace "modeOk = $result"
	result
}

private getDaysOk() {
	def result = true
	if (days) {
		def df = new java.text.SimpleDateFormat("EEEE")
		if (location.timeZone) {
			df.setTimeZone(location.timeZone)
		}
		else {
			df.setTimeZone(TimeZone.getTimeZone("America/New_York"))
		}
		def day = df.format(new Date())
		result = days.contains(day)
	}
//	log.trace "daysOk = $result"
	result
}

private getTimeOk() {
	def result = true
	if (starting && ending) {
		def currTime = now()
//		def start = timeToday(starting).time
		def start = timeToday(starting,location.timeZone).time
//		def stop = timeToday(ending).time
		def stop = timeToday(ending,location.timeZone).time
		result = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start
	}
//	log.trace "timeOk = $result"
	result
}

private hhmm(time, fmt = "h:mm a")
{
	def t = timeToday(time, location.timeZone)
	def f = new java.text.SimpleDateFormat(fmt)
	f.setTimeZone(location.timeZone ?: timeZone(time))
	f.format(t)
}

private hideOptionsSection() {
	(starting || ending || days || modes) ? false : true
}

private timeIntervalLabel() {
	(starting && ending) ? hhmm(starting) + "-" + hhmm(ending, "h:mm a z") : ""
}
